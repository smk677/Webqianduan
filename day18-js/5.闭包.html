<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
          闭包：
            闭包的条件：
              函数嵌套函数
              内部函数使用外部函数的变量
              调用外部函数
            
          闭包到底是什么：
            通俗的理解：函数内部嵌套的函数
            浏览器查看之后：内部函数的Scopes中，包含引用外部函数变量的一个对象

          闭包的作用：
            延长了局部变量的生命周期
            在外部控制局部变量

          闭包的缺点：
             局部变量长时间驻留在内存中，可能会造成内存泄漏(IE9以下)

          解决闭包带来的缺点：
             减少使用闭包
             及时释放
        */
       //1. 函数嵌套函数
        /* function outer() {
            var a = 1;//2 //3 //4
            var b = 2;

            function inner() {
                var c = 3;
                //2.内部函数使用外部函数的变量
                console.log(a++);
                // console.log(c);
            }
            return inner;
        }
        //3调用外部函数
        var fn = outer();
        console.log(fn);
        fn();//1
        fn();//2
        fn();//3

        var fn2 = outer();

        fn();//4
        fn2();//1
        fn2();//2
        fn2();//3
       
        //释放内存
        fn()=null;
        fn2()=null; */

        /* 
        垃圾回收算法
                - GC标记-清除法
                    

                - GC引用计数法
                    - 通过计数器来表示对象的引用数量，当计数器为0的时候，垃圾立刻被回收
                    - 优点：立刻回收
                    - 缺点：计数器占位、如果出现循环引用的时候无法清除

        代码优化：
            减少使用全局变量
            减少使用闭包
            将对象共有的方法添加到原型对象中
            使用字面量声明变量或数组
            减少属性的读取次数（比如和oLis.length书写在for的外边）
            减少if的判断层次，使用return，而不是else
            减少作用域链的查找层次
            事件委托
            使用碎片节点
        */
       /*  var a = function (val, index) {
             console.log(index);
             return {
                 fn: function (name) {
                     return a(name, val)
                 }
             }
         }
         var b = a(0); //
         b.fn(1); //
         b.fn(2); //
         b.fn(3); //

         var c = a(0).fn(1).fn(2).fn(3); // */

        /* var x = 1;
        var y = 2;

        function show() {
            var x = 2;
            return {
                x: x, //返回对象的时候 x已经解析为2了 将来把show的x改变了也不影响
                fun: function (a, b) {
                    x = a + b;
                }
            }
        }
        var obj = show();
        obj.fun(x, y)
        console.log(obj.x);
        
        console.log(x); */




        /* var name = "aaa";
        var obj = {
            name: "bbb",
            dose: function () {
                this.name = "ccc";
                return function () {
                    return this.name
                }
            }
        }
        alert(obj.dose().call(this)) //
        alert(obj.name) // */

        /* function Foo() {
            var i = 0;
            return function () {
                alert(i++);
            }
        }
        var f1 = Foo();
        f2 = Foo();
        f1(); //
        f1(); //
        f2(); // */


        /* function test(a, b) {
            b = a + 10;
            alert(b);
            return {
                test: function (a, b) {
                    return test(b, a);
                }
            }
        }
        var a = test(100, 200);
        a.test(300);
        a.test(400);

        var b = test(101).test(201).test(401);
        var c = test(102).test(202, 302);
        c.test();  */

      /*   function fun(n, o) {
            console.log(o)//undefined
            return {
                fun: function (m) {
                    return fun(m, n)
                }
            }
        }
        var a = fun(0)//undefined
        a.fun(1)//0
        a.fun(2)//0
        a.fun(3) // 0
 
        var b = fun(0).fun(1).fun(2).fun(3) //undefined 0,1,2

        var c = fun(0).fun(1)//undefined 0
        c.fun(2)//1
        c.fun(3) //1 */
    </script>
</body>
</html>